/*
 Generated by typeshare 1.5.0
 */

import Foundation

public struct Address: Codable {
	public let city: String
	public let zipcode: String

	public init(city: String, zipcode: String) {
		self.city = city
		self.zipcode = zipcode
	}
}

public struct Location: Codable {
	public let position: [Int32]

	public init(position: [Int32]) {
		self.position = position
	}
}

public struct Poi: Codable {
	public let address: Address
	public let location: Location

	public init(address: Address, location: Location) {
		self.address = address
		self.location = location
	}
}

public struct User: Codable {
	public let my_name: String
	public let my_age: UInt32
	public let address: Address

	public init(my_name: String, my_age: UInt32, address: Address) {
		self.my_name = my_name
		self.my_age = my_age
		self.address = address
	}
}

public enum MyEnum: Codable {
	case myVariant(Bool)
	case myOtherVariant
	case myNumber(UInt32)

	enum CodingKeys: String, CodingKey, Codable {
		case myVariant = "MyVariant",
			myOtherVariant = "MyOtherVariant",
			myNumber = "MyNumber"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, content
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .myVariant:
				if let content = try? container.decode(Bool.self, forKey: .content) {
					self = .myVariant(content)
					return
				}
			case .myOtherVariant:
				self = .myOtherVariant
				return
			case .myNumber:
				if let content = try? container.decode(UInt32.self, forKey: .content) {
					self = .myNumber(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(MyEnum.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for MyEnum"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .myVariant(let content):
			try container.encode(CodingKeys.myVariant, forKey: .type)
			try container.encode(content, forKey: .content)
		case .myOtherVariant:
			try container.encode(CodingKeys.myOtherVariant, forKey: .type)
		case .myNumber(let content):
			try container.encode(CodingKeys.myNumber, forKey: .type)
			try container.encode(content, forKey: .content)
		}
	}
}
